# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

`netscanner` is a network scanner and diagnostic tool built in Rust with a modern TUI (Terminal User Interface). It provides features like network discovery, packet dumping, port scanning, WiFi scanning, and traffic monitoring.

**Key Technologies:**
- Rust (stable channel)
- Ratatui for the TUI framework
- libpnet for low-level packet manipulation
- Tokio for async runtime
- Crossterm for terminal control

## Git Commit Guidelines

**IMPORTANT:** When creating git commits, do NOT mention that code was generated by Claude Code or any AI tool. Commits should be professional and focus on what was changed and why, not the tool used to make the change.

✅ Good commit message:
```
Fix lifetime elision warnings in component methods

Updated return type annotations to include explicit lifetime parameters
in discovery.rs, ports.rs, and other components to resolve compiler warnings.
```

❌ Bad commit message:
```
Fix lifetime warnings

Generated with Claude Code
Co-Authored-By: Claude <noreply@anthropic.com>
```

## Build and Development Commands

### Build
```bash
cargo build
cargo build --release
```

### Run
```bash
# Must be run with root privileges
sudo cargo run

# After installation, use binary with elevated privileges
sudo netscanner
```

### Testing
```bash
cargo test
```

### Linting/Format
```bash
cargo clippy
cargo fmt
```

### Platform-Specific Notes

**Windows:** Requires Npcap installation (automatically downloaded during build via build.rs). The build script downloads npcap-sdk-1.13.zip and extracts Packet.lib.

**Linux/macOS:** After `cargo install`, you may want to set proper permissions:
```bash
sudo chown root:user ~/.cargo/bin/netscanner
sudo chmod u+s ~/.cargo/bin/netscanner
```

## Architecture

### Component-Based TUI Architecture

The application follows a component-based architecture where each UI element implements the `Component` trait (defined in `src/components.rs`):

- **Component trait:** Defines lifecycle methods (`init`, `update`, `draw`, `handle_events`)
- **Action-based messaging:** Components communicate via an Action enum through unbounded MPSC channels
- **Event-driven updates:** The event loop processes TUI events, keyboard input, and timer ticks

### Main Application Flow

1. **Entry point:** `src/main.rs` initializes logging, panic handler, and creates the App
2. **App struct (`src/app.rs`):**
   - Manages the component registry (Vec<Box<dyn Component>>)
   - Runs the main event loop
   - Coordinates action dispatch between components
   - Handles application-level actions (Quit, Export, etc.)
3. **TUI (`src/tui.rs`):** Manages terminal state, event streams, and rendering
4. **Components:** Each component is self-contained with its own state and rendering logic

### Key Components

Located in `src/components/`:
- `title.rs` - Header/title bar
- `tabs.rs` - Tab navigation
- `interfaces.rs` - Network interface selection
- `wifi_scan.rs` - WiFi network scanning
- `wifi_chart.rs` - WiFi signal strength visualization
- `discovery.rs` - IPv4 CIDR scanning and host discovery
- `packetdump.rs` - Packet capture and logging (TCP, UDP, ICMP, ARP, ICMP6)
- `ports.rs` - TCP port scanning
- `sniff.rs` - Traffic monitoring with DNS records
- `export.rs` - CSV export functionality

### Action System

The `Action` enum (`src/action.rs`) defines all possible state changes in the application:
- **System actions:** Tick, Render, Resize, Quit, Suspend, Resume
- **UI actions:** Up, Down, Tab, TabChange, ModeChange
- **Network actions:** ScanCidr, InterfaceSwitch, DumpToggle, PortScan
- **Data actions:** PacketDump, Export, ExportData

Actions flow: Event → Component.handle_events() → Action → Component.update() → State change → Render

### Mode System

The app uses a mode system (`src/mode.rs`) similar to Vim:
- **Normal mode:** Default navigation mode
- **Input mode:** For text input fields (e.g., CIDR input for scanning)

Keybindings are defined per-mode in `.config/config.json5`.

### Configuration

Keybindings are loaded from `.config/config.json5`:
- Deserialized into the Config struct (`src/config.rs`)
- Mapped to Actions via custom deserializer in `src/action.rs`
- Support for multi-key combinations

Default keybindings (Normal mode):
- `q`, `Ctrl-d`, `Ctrl-c`: Quit
- `i`: Enter input mode
- `g`: Toggle graph, `d`: Toggle dump, `f`: Switch interface
- `s`: Scan CIDR, `c`: Clear, `e`: Export
- Arrow keys/Tab: Navigation
- `1-4`: Jump to specific tabs (Discovery, Packets, Ports, Traffic)

## Important Implementation Details

### Network Operations Require Root

All network scanning, packet capture, and interface operations require root/administrator privileges due to raw socket access.

### Build Script (`build.rs`)

- Injects git version info via `_GIT_INFO` environment variable
- On Windows: Downloads and extracts Npcap SDK for packet capture library linking

### Component Downcasting for Data Export

The Export action uses type downcasting (`component.as_any().downcast_ref::<T>()`) to extract data from specific components (Discovery, PacketDump, Ports) and aggregate it for CSV export.

### Async Architecture

- Main runtime: Tokio with `#[tokio::main]`
- Event loop runs asynchronously
- Components can spawn background tasks for network operations
- Packet capture uses async channels for data flow

## Common Modifications

### Adding a New Component

1. Create a new file in `src/components/`
2. Implement the `Component` trait
3. Add module declaration to `src/components.rs`
4. Register component in `App::new()` in `src/app.rs`
5. Add any new Actions to `src/action.rs`

### Adding Keybindings

1. Define the Action variant in `src/action.rs`
2. Add deserializer case in `Action::deserialize()`
3. Add keybinding to `.config/config.json5`
4. Handle the Action in relevant component's `update()` method
